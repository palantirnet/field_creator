<?php
/**
 * @file
 * A module to create fields and instances based on csv's from the build spec.
 *
 * @copyright (C) Copyright 2013 Palantir.net, Inc.
 */

/**
 * Implements hook_init().
 */
function field_creator_init() {

  module_load_include('install', 'field_creator');
  // field_creator_create_field_bases();
  // field_creator_create_field_instances();
  // @todo
  // hook_field_creator_suggested_field_base_name_alter()
  // hook_field_creator_suggested_field_base_config_alter()
  // hook_field_creator_suggested_field_instance_config_alter()
  // hook_field_creator_suggested_field_base_name_alter()
}

/**
 * Implements hook_menu()
 */
function field_creator_menu(){
  $items = array();
  
  $items['admin/config/development/field-creator'] = array(
    'title' => 'Field Creator',
    'description' => 'Configuration for the field creator module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('field_creator_build_form'),
    'access arguments' => array('administer users'),
    'type' => MENU_NORMAL_ITEM,
  );
  
  return $items;
}

/**
 * 
 * @param type $form
 * @param type $form_state
 * @return array
 */
function field_creator_build_form($form, &$form_state){
  
  // Help text
  $form['help']['#markup'] = '<p>' . t('You can press the button below to build your fields.
    Make sure the csv files are filled out and that you have enabled all of the modules for the 
    fields you want to use.') . '</p>';
  
  // Button
  $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Build fields'),
  );
  return $form;
}

/**
 * A submit callback for field_creator_build_form().
 *
 * @param array $form
 *   A normal Drupal form array.
 *
 * @param array $form_state
 *   A normal Drupal form_state array.
 */
function field_creator_build_form_submit($form, &$form_state) {
  $batch = array(
    'title' => t('Building'),
    'operations' => array(),
    'finished' => 'field_creator_batch_finished',
    'file' => 'field_creator.install',
  );
  
  $types = field_get_desired_node_types();
  foreach ($types as $type_machine_name => $type_info) {
      $batch['operations'][] = array('field_creation_batch_node_type', array($type_machine_name, $type_info));
  }
  
  $vocabs = field_creator_get_desired_taxonomy_vocabularies();
  // Insert vocabularies for every machine name that doesn't exist yet.
  foreach ($vocabs as $vocab) {
    $batch['operations'][] = array('field_creation_batch_vocab', array($vocab));
  }
  
  // Load all the existing field bases up-front so that we don't
  // have to rebuild the cache all the time.
  field_info_cache_clear();
  $existing_fields = field_info_fields();
  // Get all the desired fields.
  $desired_fields = field_creators_get_desired_fields();
  // Loop over the desired fields and create them.
  foreach ($desired_fields as $field_name => $field) {
    // Create the field if it doesn't exist yet.
    if (empty($existing_fields[$field_name])) {
      $batch['operations'][] = array('field_creation_batch_field_base', array($field));
    }
  }
  
  field_info_cache_clear();
  $desired_field_instances = field_creators_get_desired_field_instances();
  foreach ($desired_field_instances as $field_instance_name => $field_instance) {
    // If the field base information does not exist yet, cancel out.
    if (!field_info_field($field_instance['field_name'])) {
      continue;
    }
    $batch['operations'][] = array('field_creation_batch_field_instance', array($field_instance, $field_instance_name));
  }

  batch_set($batch);
}

/**
 * 
 * @param type $success
 * @param type $results
 * @param type $operations
 */
function field_creator_batch_finished($success, $results, $operations) {
  // The 'success' parameter means no fatal PHP errors were detected. All
  // other error management should be handled using 'results'.
  if ($success) {
    $message = t('The fields have been built.');
  }
  else {
    $message = t('Finished with an error.');
  }
  drupal_set_message($message);
  variable_set('menu_rebuild_needed', TRUE);
}

/**
 * Add a node type.
 * @param type $type_machine_name
 * @param type $type_info
 * @param array $context
 */
function field_creation_batch_node_type($type_machine_name, $type_info, &$context) {
  $context['message'] = t('Creating node types.');
  // If the node type doesn't exist yet, create it.
  if (!node_type_load($type_machine_name)) {
    node_type_save($type_info);
  }
  else {
    // @todo set a warning message similar to
    // drupal_set_message('The node type ' . $type_machine_name . ' already exists', 'warning');
    // $context
  }
}

/**
 * Add a vocabulary
 * @param type $vocab
 * @param type $context
 */
function field_creation_batch_vocab($vocab, &$context) {
  $context['message'] = t('Creating vocabularies.');
  if (FALSE === taxonomy_vocabulary_machine_name_load($vocab['vocabulary_machine_name'])) {
      $new_vocab = new stdClass();
      $new_vocab->machine_name = $vocab['vocabulary_machine_name'];
      $new_vocab->name = $vocab['vocabulary_label'];
      $new_vocab->description = $vocab['description'];
      taxonomy_vocabulary_save($new_vocab);
    }
}

/**
 * Add field base.
 * @param type $field
 * @param array $context
 */
function field_creation_batch_field_base($field, &$context) {
  $context['message'] = t('Creating field bases.');
  field_create_field($field);
}

/**
 * Add field instance.
 * @param type $field_instance
 * @param type $field_instance_name
 * @param array $context
 */
function field_creation_batch_field_instance($field_instance, $field_instance_name, &$context) {
  $context['message'] = t('Creating field instances.');
  // $field_instance name should look like
  // "node-org_entity-field_text_title_short".
  list($entity, $bundle, $field_name) = explode('-', $field_instance_name);
  // Make sure the field instance does not exist yet.
  if (field_info_instance($entity, $field_name, $bundle) === NULL) {
    field_create_instance($field_instance);
  }
}

/**
 * Implements hook_field_creator_desired_field_config_alter().
 */
function field_creator_field_creator_desired_field_config_alter(&$field_config, $field_csv_settings) {

  $field_name = $field_csv_settings['machine name'];
  $cardinality = $field_csv_settings['num values'];

  if (!empty($cardinality)  && !empty($field_config['cardinality'])) {
    if ($cardinality === 'unlimited') {
      $cardinality_to_set = '-1';
    }
    elseif (is_numeric($cardinality)) {
      // @todo don't uncomment this until there is a test.
      // $cardinality_to_set = $cardinality;
    }
    if (!empty($cardinality_to_set)) {
      $field_config['cardinality'] = $cardinality_to_set;
    }
  }

  if (strpos($field_name, 'field_ref_') === 0) {
    if (!empty($field_config['settings']['handler_settings']['target_bundles'])) {
      // Most of the reference fields can point at only one field type.
      // @todo, move to a csv.
      $target_bundle_by_field = array(
        'field_ref_org_entities' => 'org_entity',
        'field_ref_services' => 'service',
        'field_ref_locations' => 'location',
        'field_ref_events' => 'event',
        'field_ref_conditions' => 'condition',
        'field_ref_persons' => 'person',
        'field_ref_video' => 'video',
        'field_ref_slideshow' => 'slideshow',
        'field_ref_pages' => 'general_page',
        'field_ref_person_contact' => 'person',
        'field_ref_org_entities_parents' => 'org_entity',
        'field_ref_treatments' => 'treatment',
        'field_ref_persons_author' => 'person',
      );

      if (!empty($target_bundle_by_field[$field_name])) {
        $single_target_bundle = $target_bundle_by_field[$field_name];
      }
      // @todo field_ref_see_also
    }
    else {
      // @todo log an error.
    }
  }
  elseif (strpos($field_name, 'field_refterm_') === 0) {
    // No longer pulling in fields with Vocabs.
    // @todo find out if this can be deleted.
    /*if (!empty($field_config['settings']['handler_settings']['target_bundles'])) {
      // @todo, this section of code could be moved to a helper function.
      $base_fields_csv_path = drupal_get_path('module', 'field_creator') . '/csv/build-spec-fields-vocab-mapping.csv';
      $vocab_machine_names_by_field_machine_name = field_creator_getMappingFromCSV($base_fields_csv_path, 1, 2);
      if (!empty($vocab_machine_names_by_field_machine_name[$field_name])) {
        $single_target_bundle = $vocab_machine_names_by_field_machine_name[$field_name];
      }
    }*/
  }

  if (!empty($single_target_bundle)) {
    $field_config['settings']['handler_settings']['target_bundles'] = array(
      $single_target_bundle => $single_target_bundle,
    );
  }
}

/**
 * Load field base include files.
 *
 * @return array
 *   An array of field bases.
 */
function field_creator_load_base() {
  $fields = &drupal_static(__FUNCTION__);

  if (!isset($fields)) {
    field_creator_load_includes();
    $fields = module_invoke_all('field_creator_base');
  }

  return $fields;
}

/**
 * Load field instance include files.
 *
 * @return array
 *   An array of field instances.
 */
function field_creator_load_instance() {
  $fields = &drupal_static(__FUNCTION__);

  if (!isset($fields)) {
    field_creator_load_includes();
    $fields = module_invoke_all('field_creator_instance');
  }

  return $fields;
}

/**
 * Helper to load include files on behalf of other modules.
 *
 * NOTE: module_load_all_includes() won't work because we store files on
 * behalf of other modules.
 */
function field_creator_load_includes() {
  $loaded = &drupal_static(__FUNCTION__);

  if (isset($loaded)) {
    return;
  }
  // Find all the files in the directory with the correct extension.
  $include_path = drupal_get_path('module', 'field_creator') . '/fields';
  $files = file_scan_directory($include_path, "/\.field_creator\.inc$/");

  // Load each file and dig out its field bases.
  foreach ($files as $filepath => $file) {
    require_once $filepath;
  }

  $loaded = TRUE;
}
